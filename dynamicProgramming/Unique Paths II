class Solution {
public:

    // int funRec(int i, int j, vector<vector<int>>&obstacleGrid){
    //     //extra edge case to check whether given cell is -1 or 0, if it is -1 then we can't go and return 0
    //     if(i >=0 && j>=0 && obstacleGrid[i][j] == 1) return 0;
    //     if(i==0 && j==0) return 1;
    //     if(i<0 || j<0) return 0;

    //     int up = funRec(i-1, j, obstacleGrid);
    //     int left = funRec(i, j-1, obstacleGrid);

    //     return up+left;
    // }

    // int funMemo(int i, int j, vector<vector<int>>& nums, vector<vector<int>>&dp){
    //     if(i>=0 && j>=0 && nums[i][j] == 1) return 0;
    //     if(i==0 && j==0) return 1;
    //     if(i<0 || j<0) return 0;

    //     if(dp[i][j] != -1) return dp[i][j];

    //     int up = funMemo(i-1, j, nums, dp);
    //     int left = funMemo(i, j-1, nums, dp);

    //     return dp[i][j] = up+left;
    // }

    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        vector<vector<int>>dp(m, vector<int>(n, -1));
        //recursion
       // return funRec(m-1, n-1, obstacleGrid);

       //memoization
        //return funMemo(m-1, n-1, obstacleGrid, dp);

       //tabulation
       //dp[0][0] = 1;
       
       for(int i=0; i<m; i++){
           for(int j=0; j<n; j++){
               if(obstacleGrid[i][j] == 1) dp[i][j] = 0;
              else if(i==0 && j==0)
                    dp[i][j] = 1;
               
               else{
                    int up=0, left=0;
                   if(i>0)
                        up = dp[i-1][j];
                    if(j>0)
                        left = dp[i][j-1];
                    dp[i][j] = up+left;
               }
               
           }
       }
       return dp[m-1][n-1];
    }
};
